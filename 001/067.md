Main Lava Chimpanzee

High

# Raffle winners able to claim more eth using reentrancy

## Summary
Raffle winners claims their prize using their Raffle ID. The problem arise when claiming Ether as prize.
## Vulnerability Detail
The  implementation does not follow the Check-Effect-Interact allowing reentrancy to steal all ether in this contract.
```solidity
    function claimPrize(uint256 raffleId) external { 
    -- SNIP --
        } else if (raffleType == RaffleType.ETH) {
            unchecked { _ethLocked -= _ethRaffles[raffleId]; }
            _sendETHPrize(_ethRaffles[raffleId], msg.sender);
        } else revert InvalidRaffle();
        if (msg.sender != rafflePrize.winner) revert UnauthorizedToClaim();
        if (rafflePrize.status == RafflePrizeStatus.CLAIMED) revert AlreadyClaimed();
        rafflePrize.status = RafflePrizeStatus.CLAIMED;
        
    -- SNIP --
```
## Impact
Winners able to perform reentrancy and drain this contract.
## Code Snippet
https://github.com/sherlock-audit/2024-08-winnables-raffles/blob/e8b0603f6a155c7505dacc77194ae6789d0dbe7a/public-contracts/contracts/WinnablesPrizeManager.sol#L118
## Tool used

Manual Review

## Recommendation
Implement Check-Effect-Interact pattern
```diff
    function claimPrize(uint256 raffleId) external {
        RafflePrize storage rafflePrize = _rafflePrize[raffleId];
        RaffleType raffleType = rafflePrize.raffleType;
+       if (msg.sender != rafflePrize.winner) revert UnauthorizedToClaim();
+       if (rafflePrize.status == RafflePrizeStatus.CLAIMED) revert AlreadyClaimed();
+       rafflePrize.status = RafflePrizeStatus.CLAIMED;
        if (raffleType == RaffleType.NFT) {
            NFTInfo storage raffle = _nftRaffles[raffleId];
            _nftLocked[raffle.contractAddress][raffle.tokenId] = false;
            _sendNFTPrize(raffle.contractAddress, raffle.tokenId, msg.sender);
        } else if (raffleType == RaffleType.TOKEN) {
            TokenInfo storage raffle = _tokenRaffles[raffleId];
            unchecked { _tokensLocked[raffle.tokenAddress] -= raffle.amount; }
            _sendTokenPrize(raffle.tokenAddress, raffle.amount, msg.sender);
        } else if (raffleType == RaffleType.ETH) {
            unchecked { _ethLocked -= _ethRaffles[raffleId]; }
            _sendETHPrize(_ethRaffles[raffleId], msg.sender);
        } else revert InvalidRaffle();
-       if (msg.sender != rafflePrize.winner) revert UnauthorizedToClaim();
-       if (rafflePrize.status == RafflePrizeStatus.CLAIMED) revert AlreadyClaimed();
-       rafflePrize.status = RafflePrizeStatus.CLAIMED;
        emit PrizeClaimed(raffleId, msg.sender);
    }
```