Broad Red Skunk

Medium

# In certain situations, winner can't claim his prize due to unbounded ticket count

## Summary
In buyTickets() function, ticketCount variable is defined as uint16 which makes 65535 at max. If an user win the raffle with a ticket which is far enough from the starting point, then user can't claim his reward due to out of gas problem.

## Vulnerability Detail
In Winnables platform, buyTickets() function takes ticketCount argument and user can buy ticket using the signature which is generated by the off-chain API system and it mints tickets to user in WinnablesTicket contract. Based on the minting algorithm, it set the first place of the current pointer with user address and it updates the pointer to currentPointer + ticketCount point:

```solidity
 function buyTickets(
        uint256 raffleId,
        uint16 ticketCount,
        uint256 blockNumber,
        bytes calldata signature
    ) external payable {
        if (ticketCount == 0) revert InvalidTicketCount();
        _checkTicketPurchaseable(raffleId, ticketCount);
        _checkPurchaseSig(raffleId, ticketCount, blockNumber, signature);

        Raffle storage raffle = _raffles[raffleId];
        uint256 participation = uint256(raffle.participations[msg.sender]);
        uint128 totalPaid = uint128(participation) + uint128(msg.value);
        uint32 totalPurchased = uint32(participation >> 128) + uint32(ticketCount);
        unchecked {
            raffle.participations[msg.sender] = bytes32(
                (participation & type(uint256).max << 160)
                | totalPaid |
                uint256(totalPurchased) << 128
            );
        }
        unchecked {
            raffle.totalRaised += msg.value;
            _userNonces[msg.sender]++;
            _lockedETH += msg.value;
        }
&>      IWinnablesTicket(TICKETS_CONTRACT).mint(msg.sender, raffleId, ticketCount);
        IWinnablesTicket(TICKETS_CONTRACT).refreshMetadata(raffleId);
    }
  function mint(address to, uint256 id, uint256 amount) external onlyRole(1) {
    if (to == address(0)) {
      revert TransferToAddressZero();
    }
    address operator = msg.sender;
    uint256 startId = _supplies[id];

    unchecked {
      _balances[id][to] += amount;
&>    _supplies[id] = startId + amount;
    }

&>  _ticketOwnership[id][startId] = to;
    emit NewTicket(id, startId, amount);
    emit TransferSingle(operator, address(0), to, id, amount);

    _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount);
  }
```

So, basicly if we want to learn the owner of the ticket X, we need to go back one by one until reaching non-zero address:

```solidity
  function ownerOf(uint256 id, uint256 ticketId) public view returns (address) {
    if (ticketId >= _supplies[id]) {
      revert InexistentTicket();
    }
    while (_ticketOwnership[id][ticketId] == address(0)) {
      unchecked { --ticketId; }
    }
    return _ticketOwnership[id][ticketId];
  }
```

The problem arise in here. If the winner ticket is far enough to revert the execution, winner can't get the prize because system can't determine the winner in the raffle:

```solidity
    function propagateRaffleWinner(address prizeManager, uint64 chainSelector, uint256 raffleId) external {
        Raffle storage raffle = _raffles[raffleId];
        if (raffle.status != RaffleStatus.FULFILLED) revert InvalidRaffleStatus();
        raffle.status = RaffleStatus.PROPAGATED;
&>      address winner = _getWinnerByRequestId(raffle.chainlinkRequestId);
    


        _sendCCIPMessage(prizeManager, chainSelector, abi.encodePacked(uint8(CCIPMessageType.WINNER_DRAWN), raffleId, winner));
        IWinnablesTicket(TICKETS_CONTRACT).refreshMetadata(raffleId);
        unchecked {
            _lockedETH -= raffle.totalRaised;
        }
    }

function _getWinnerByRequestId(uint256 requestId) internal view returns(address) {
        RequestStatus storage request = _chainlinkRequests[requestId];
        uint256 supply = IWinnablesTicket(TICKETS_CONTRACT).supplyOf(request.raffleId);
        uint256 winningTicketNumber = request.randomWord % supply;
&>      return IWinnablesTicket(TICKETS_CONTRACT).ownerOf(request.raffleId, winningTicketNumber);
    }
```

## Proof of Concept
### Scenario:

- A raffle event is planned
- Alice wants to buy really high amount of tickets and she takes 2000 tickets ( because she wants to win :) )
-- Now, her address set to startId ( pointer ) of the _ticketOwnership variable and new pointer is startId + ticketCount
- Let say Alice wins the riffle with her 1800th ticket. 
- System will try to reach 0 point which stores Alice's address in order to detect Alice's address
- Due to high amount of gas usage system couldn't detect the address
- Result: Raffle couldn't be finalized 

## Impact
Main functionality problem

## Code Snippet
https://github.com/sherlock-audit/2024-08-winnables-raffles/blob/81b28633d0f450e33a8b32976e17122418f5d47e/public-contracts/contracts/WinnablesTicketManager.sol#L182

## Tool used

Manual Review

## Recommendation

Applying a reasonable the maximum purchasable ticketCount in one execution to buyTickets() function can solve the problem.